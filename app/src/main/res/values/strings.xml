<resources>
    <string name="app_name">DataStructure</string>
    <!--算法性能分析与度量-->
    <string name="arithmetic">###数据结构
**数据结构是相互之间存在一种或多种特定关系的数据元素的集合，可以用二元组来表示**
```
DataStructure（D，S）
D是数据元素的有限集，S是D上关系的有限集
```
如数组是一种现行数据结构，由n个元素有序排列而成：Array=（D，S）
D={a1,a2,…,an}
S={R}
###算法与算法分析
####算法
**是一组完成特定任务的有限指令序列，都满足以下准则。**
**输入**：进行处理的输入数据
**输出**：算法执行后产生的结果数据
**确定性**：算法每一个步骤都必须有明确的语义，无二义性
**有限性**：算法的每一条执行路径都必须能够在有限的步骤内完成，而且会在可预期和可接受的时间内完成
**有效性**：算法的每一条指令都是有确定结果的，而且是可以利用某种程序设计语言来实现的
####时间复杂度
**是按某种算法设计的程序在计算机上执行时花费的CPU时间的度量**
基本操作的执行次数可以作为算法时间复杂度的度量，但在多数场合下，不需要精确计算基本操作的执行次数，而只是关注f(n)中阶数最高的项，同时忽略掉低阶项系数以及其他低阶的项，例如，如果最高阶是n2，因此可以称该算法的时间复杂度是“平方阶”的。为了技术方便，引入“O”算子（读作“大O”），即该算法中O（f（n））=O（n2）。因此，算法的时间复杂度T（n）是问题规模n的函数，可以记做T（n）=O（f（n））
常见的算法时间复杂度有O（1）、O（n）、O（n2）、O（log2n）和O（2n），曾为常量阶、线性阶、平方阶、对数阶和指数阶
####空间复杂度
**是按某种算法设计的程序在计算机上执行时需要使用的存储空间的度量**
一个程序在计算机上运行时，需要用到一部分存储空间，这些空间用于存放程序代码和各类数据等。一个程序为完成某个任务而占用的数据存储空间的大小也是评价这个程序性能优劣的一个重要指标。在忽略一些必要的临时变量、输入/输出所需要的工作单元后，作为算法的空间复杂度，着重考查的是为了完成这个任务所必须附加的数据存储空间的大小。这个附加存储空间的大小往往因不同算法设计而异，并且与问题规模相关。因此，算法的空间复杂度S（n）是问题规模n的函数，可以纪委S（n）=O（f（n））在一些情况下，S（n）是常量阶的，这意味着无论问题规模n的大小如何，算法所需要的附加存储空间是固定的，对数据操作利用的是输入数据所占用的空间，我们称此算法是“原地工作”</string>
    <string name="f_half_1">low、mid、high分别指向待查表的下界、中点和上界，key为给定值。</string>
    <string name="f_half_2">初始时令low=0，high=n-1。</string>
    <string name="f_half_3">mid=（low+high）/2。【取整】</string>
    <string name="f_half_4">将key与mid指向的记录关键字比较\n若key==r[mid].key，查找成功，返回mid\n若key＜r[mid].key，待查元素若存在必定在区间的前半部分，则high=mid-1；\n若key＞r[mid].key，待查元素若存在必定在区间的后半部分，则low=mid+1。</string>
    <string name="f_half_5">重复（2）、（3）操作，直至查找成功或者当low>high时，查找失败，返回-1。</string>
    <string name="f_half_6">int low=0, high=R.m_size-1; //low表示所查区间的下界，high表示所查区间的上界</string>
    <string name="f_half_7">折半查找的过程中，每次都以查找区间中点的元素作为比较对象，这个查找过程可用二叉树来描述。查找任一元素时，正好走了一条从根节点到给定值所在节点的路径，这棵二叉树成为判定书，其深度与具有相同节点总数的完全二叉树的深度一致。用这边查找法在查找成功时进行比较的关键字个数最多不超过判定书的深度。</string>
    <string name="f_half_8">利用判定树，可以计算出折半查找成功时的平均查找长度。假设判定树的高度为h，结点总数为n。第k层节点数最多为2^(k-1)，该层节点查找成功需要的比较次数为k次。则在等概率情况下ASL＜=(1+2*2+3*2^2+…+h*2^(h-1))/n。当有序表的长度n=2^h-1时，折半查找的判定树是深度为h的满二叉树。此时ASL=(n+1)/n*log2^(n+1)-1≈log2^(n+1)-1。因此折半查找的时间复杂度为O(log2^n)</string>
</resources>
